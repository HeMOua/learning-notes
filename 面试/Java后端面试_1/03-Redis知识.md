# Redis知识

## 什么是 redis ？

redis 是一个高性能的非关系型数据库，由c语言编写，与传统数据库不同，它存储在内存中，所以读写速度非常快，每秒可以处理超10万次的读写操作，因此常用作缓存。

## 优缺点

优点：

+ 读写性能好
+ 支持数据持久化，包括 AOF 和 RDB 两种持久化方式
+ 数据结构丰富
+ 支持事务，redis 所有操作都是原子性的，并且还支持所有操作合并再原子性执行
+ 支持主从复制，可以创建多个备份节点，提高容错性和可用性

缺点：

+ redis 将数据存在内存中，会受到内存大小的限制
+ redis 处理请求是单线程的，在极高的并发情况下会成为瓶颈
+ 缺乏复杂的查询支持

## redis 和 memcached

相同点：

+ 两者读写性能都比较高
+ 都是基于内存的数据库，常用作缓存
+ 都采用键值对的方式存储数据

不同点：

+ redis 支持的数据类型更多，比如字符串、列表、集合、散列表，memcached只支持简单的key/value
+ redis 使用多路io复用，memcached 使用多线程阻塞io模式

## redis 为什么这么快

+ 运行在内存
+ 使用单线程，避免上下文切换造成的性能损耗
+ 使用多路io复用

## redis 6.0 之后多线程

主要是为了解决网络 IO 的读写瓶颈问题，执行命令还是单线程执行的

## redis 的数据类型

+ string
+ list
+ hash
+ set
+ zset

## redis 的数据结构

+ 简单动态字符串：redis没有使用c语言传统的字符串表示，而是构建了一种名为简单动态字符串的抽象类型
+ 链表：提供了高效的节点重排能力，以及顺序的节点访问方式。链表是list的底层实现之一
+ 字典：一种保存键值对的抽象数据结构。redis 的数据库就是使用字典作为底层实现
+ 整数集合：整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数元素，并且元素不多时，就会使用intset作为集合键的底层实现
+ 压缩列表：redis 为节约内存而开发，一种连续内存块的顺序数据结构
+ 跳跃表：一种有序数据结构，在每个节点中维持多个指向其他节点的指针。可以实现平均查询时间复杂度为 O(logn) 最坏为 O(n).
  + 使用场景：
    + 有序集合键
    + 集群节点用作内部数据结构
  + 使用多级索引来实现快速检索
    + 第一级索引的节点数量时原始链表节点的 1/2，第二级索引的数量时第一级的 1/2
    + 以此类推，上一级索引节点数是底一层索引节点数的 1/2
  + 优点：
    + 内存占用少，可以根据参数来控制占用内存的大小
    + 查询不会比其他平衡树差，比如红黑树
    + 容易实现与维护
  + 与普通跳跃表的不同：
    + 原始链表是双向链表
    + 跳跃表分数可以重复，重复分数的节点根据数据内容来进行字典排序
    + 可以很方便的算出每个元素的排名

## 应用场景

+ 缓存：redis是基于内存的，读写非常快，而且还拥有键过期和键淘汰功能，适合做缓存
+ 排行榜：redis 提供的有序集合可以很方便的实现排行榜（zrevrange）
+ 分布式锁：redis 的 setnx 来实现分布式锁
+ 社交功能：实现共同好友、共同关注（set交集）
+ 计数器：string 自增实现计数器
+ 消息队列：redis 提供了发布、订阅、阻塞队列等功能，可以实现一个简单的消息队列

## redis 单线程如何提高cpu利用率

可以在一个服务器上部署多个实例，把他们当做不同的服务器使用

## 键过期的删除策略

### 过期删除策略

+ 惰性删除：在访问这个键的时候才检测是否过期，如果过期则删除
  + 优点：节约cpu资源
  + 缺点：如果键长期没有被访问，则会在内存中占用大量资源
+ 定时删除：为每个设置过期时间的都创建一个定时器，到达时间后自动清除
  + 优点：过期的key能被立即清除，节约内存空间
  + 缺点：会占用大量cpu资源去处理过期数据
+ 定期删除：每隔一段时间就对一些键进行检查，并删除其中过期的键
  + 是惰性删除和定时删除的一个折中，避免了cpu资源的占用，以及节约内存空间

### redis 的内存淘汰机制

redis 是基于内存的，容量有限，因此当数据量大于 redis 允许的最大内存后，会触发内存淘汰机制

+ 四种策略只针对设置了过期时间的键
  + volatile-lru（least recently used）：移除最近最少使用的键
  + volatile-lfu（least frequently used）：移除使用频率最低的键
  + volatile-random：随机淘汰
  + ttl（time to live）：删除过期的键
+ 三种策略针对所有键
  + allkeys-lru
  + allkeys-lfu
  + allkeys-random
+ noeviction：不淘汰键，如果有写入操作，则报错

### // TODO lru 实现

## redis 的持久化

### 什么是redis持久化

因为redis是基于内存，为了防止突发情况，需要将数据持久化到硬盘上，防止数据丢失

### 持久化机制

***RDB（redis database）***

redis默认的持久化策略，按照一定的时间间隔将内存数据以快照的方式持久化到磁盘上

优点：

+ 适合对大规模数据进行恢复，启动效率比 AOF 高
+ 备份只产生一个文件，方便持久化

缺点：

+ 安全性较低，会丢失最后一次备份后修改的数据

***AOF（append only file）***

以日志的形式记录 redis 的每一次写、删除操作，不会记录查询操作，以文本的方式进行记录，可以打开文本，查看具体的操作记录

优点：

+ 安全性高，相比RDB丢失的数据更少。redis 还提供3中日志同步策略，每秒同步、每修改同步和不同步。
+ 日志使用 append 追加模式，即使出现突然宕机的情况，也不会影响已存在的内存

缺点：

+ 相同数据情况下，aop 文件大小通常大于 RDB，并且 aop 恢复效率没有 RDB 高
+ aof 运行运行效率慢于 RDB

## redis 事务

### 什么是 redis 事务

redis 事务是一种单独隔离操作，可以保证事务中的命令按顺序、一次性完成一系列命令，而不被其他命令打断，redis事务的主要作用就是**串联多个命令防止其他命令插队**

### redis 事务的相关命令

+ `multi`：标记一个事务块的开始
+ `watch`：标记要监视的一个或多个key，如果被监视的key被修改或删除，那么之后的事务就不会被执行
+ `unwatch`：取消对key的监视。
  + 如果 key 已经执行过 exec 或 discard，则无需在执行 `unwatch`
  + 如果执行了 `exec`，就是开始事务，`watch` 命令就已经生效了
  + 如果执行了 `discard`，就是取消事务，同时也会取消对所有 key 监视

+ `discard`：命令取消事务，放弃事务队列里的所有命令，如果事务之后监视了某些 key，那么也会对这些 key 取消监视

### redis 事务的特性

+ **不能保证原子性**，虽然单条命令是原子性的，但是不能保证事务是原子性的
+ **事务具有隔离性**，但不具有隔离级别，事务执行的过程中，不会被其他命令所打断
+ **事务不支持回滚**，redis事务执行过程中命令执行失败，其他的命令仍然可以执行

### redis 事务为什么不支持回滚？

redis 事务中，允许执行失败，但是redis会继续执行其他的命令，而不是回滚所有命令，原因如下：

+ redis 命令只在两种情况下失败：
  + 语法错误时
  + key 的数据类型不匹配时
  + 这些错误都是编程错误，这应该在测试时就纠正过来，而不是在生产环境下
+ 因为 redis 不需要回滚，可以让 redis 的内部实现非常简单高效

## redis 集群、主从、哨兵

*为什么要使用集群？*

+ 不能保证数据的可靠性，服务部署在一台服务器上，一旦宕机服务就无法使用
+ 存在性能瓶颈，内存容量有限，处理能力有限

### redis 集群的实现方案

+ 主从模式
+ 哨兵模式
+ redis 自研
+ redis clustert

#### 主从模式

redis 单机版服务部署在一个服务器上，因此读写都在同一台服务器上，这是读写不分离的，因此如果出现磁盘损坏的情况，就会导致数据不可用。

为了避免出现这种情况，redis 提供了复制功能，在 master 数据库更新了数据后，自动会将更新同步到 slave 从数据库中，这样我们可以在 master 数据库上进行写，slave 数据库上进行读。

优点：

+ 高可靠性，master 服务器出现了故障，可以切换到从数据库中
+ 读写分离，可以扩展 master 服务器的读能力，有效应对大并发量的读操作

缺点：

+ 不具有自动容错和恢复功能，需要手动将从服务器提升为主服务器，可用性较低

#### 哨兵模式

哨兵模式的核心还是主从复制，相对于主从模式多一个**竞选机制**（哨兵集群），主要是为了解决主从模式“无法自动容错和恢复”的问题。

哨兵模式多了一个哨兵集群，主要作用：

+ 监视所有服务器是否正常运行：可以发送命令返回所监视服务器的运行状态，同时哨兵之间也可以相互监视
+ 故障切换：如果 master 宕机，可以从 slave 自动竞选出一个服务器作为 master 服务器，然后通过发布订阅，推送到其他从服务器。

优点：

+ 基于主从模式，解决了 master 出现故障无法自动切换的问题

缺点：

+ 浪费资源：每个节点都保存了一份完整数据，数据量过大时，会影响主从同步的性能
+ master 宕机后，在选举完新的 master 之前，redis 会开启保护机制，禁止写操作，直到选举成功
+ 只有一个 master 来进行写操作，写请求会受到单机性能瓶颈

#### redis 自研

为了解决哨兵模式每个数据节点都是全量存储数据的问题，有的公司自行研发的 redis 集群方案

***客户端分片***

将分片逻辑放在客户端中，然后按照预定义好的路由规则（哈希计算），将不同的 key 访问请求转发到不同的 redis 实例中，查询数据时，将结果汇总后返回。

优点：

+ 各个 redis 实例相互独立，扩展十分方便，灵活性抢

缺点：

+ 客户端不支持动态修改删除 redis 实例节点，如果 redis 实例拓扑发生变化，每个客户端都需要进行调整
+ 维护成本高，集群出现问题需要运维人员和开发人员合作处理
+ 不同的客户端程序，维护相同的路由分片逻辑成本大，比如 java 和 php 虽然使用同一个 redis 集群，但是要开发两个逻辑一样，但是不同的分片逻辑

> ***一致性 Hash***（客户端分片常用）
>
> 1. 对 key 计算 hash 值
> 2. 对 2^32 取模
>
> 缺点：
>
> + 当节点实例比较少时，容易出现部分节点数据过多，部分节点数据过少，造成数据倾斜的现象（通过引入虚拟节点来解决这个问题）

***代理分片***

客户端分片的缺点是每次 redis 实例发生变化，每个客户端都需要进行调整，为了解决这个问题，研发出了代理分片方式。

它将客户端分片模块单独分了出来，作为redis服务端和客户端连接的桥梁

优点：

+ redis 实例拓扑发生变化无需修改每个客户端

缺点：

+ redis 客户端的每个请求都要经过代理，会存在性能损失

#### redis cluster

通过引入虚拟槽。redis cluster 总共有 2^14（16384）个槽位，每个 master 节点都会拥有一个槽位范围。slave 节点不分配槽位，只拥有读权限。

然后通过 CRC16 算法计算 key 的 hash 值，并将结果对 2^14 取模，就能得到对应的槽位。

优点：更加方便的添加和移除节点，只需要修改 hash 槽，而不需要操作 redis 节点实例

每个节点通过周期性的想其他节点发送 ping/pong 命令，交互节点信息，若干次交互后，就能使得集群的状态达成一致。



## redis 分区

## redis 分布式问题

### 什么是分布式锁？

锁的作用是同步，保证共享资源在同一时刻只能由一个线程访问。而分布式锁就是在分布式的场景下，保证共享资源只能由一个线程访问。

### 分布式锁有哪些特性？

+ 互斥性：任意时刻，一条数据只能被一台机器上的一个线程获取
+ 高可用性：要保证时时刻刻都有较高的可用性，即使节点宕机，客户端也要能正确的获取或释放锁
+ 释放死锁：即使锁定资源的客户端发生故障，也要保证锁可以被释放

### 分布式锁的实现方式？

+ 基于关系型数据库：
+ 基于 redis：
+ 基于 zookeeper：

### redis 实现分布式锁

通过 `setnx` 命令，此命令的作用是如果不存在 key 则设置值，如果存在 key 则什么都不做

我们通过 `setnx` 拿到锁 -> 执行业务流程 -> 释放锁

同时为了防止程序异常，设置锁过期时间，让它自己超时释放

*问题1*：由于第一个业务执行时间超过了设置值，锁自动释放了，这时第二个线程就可以获取到锁了，但是这时第一个才业务执行完毕，并将锁释放了，也就是说吧第二个线程的锁给删了。

解决：获取锁时加上自己的唯一标识，删除锁前进行对比，确保锁由同一个线程完成删除和释放操作

*问题2*：完成锁对比的那一刻，cpu 突然切换到了另一个线程，同时锁也到期自动释放了，另一个线程结束时间片后返回到第一个线程，执行删锁

解决：使用 lua 脚本，确保判断锁，和删除锁操作是原子性的
